#!KAMAILIO
# =============================================================================
# Kamailio Configuration for High-Availability VoIP System
# Target: 600-800 concurrent calls
# Hardware: 16 cores, 64 GB RAM per node
# =============================================================================

####### Global Parameters #########

#!define WITH_POSTGRES
#!define WITH_AUTH
#!define WITH_USRLOCDB
#!define WITH_DIALOG
#!define WITH_DISPATCHER
#!define WITH_ANTIFLOOD
#!define WITH_ACCDB

# Database connection - MUST USE LOCAL PostgreSQL per node
# Node 1: postgres://kamailio:PASSWORD@172.16.91.101/voipdb
# Node 2: postgres://kamailio:PASSWORD@172.16.91.102/voipdb
# IMPORTANT: Change the IP below to match your node's LOCAL PostgreSQL IP
#!define DBURL "postgres://kamailio:PASSWORD@172.16.91.101/voipdb"

# FreeSWITCH dispatcher set
#!define DS_SETID 1

# SIP listen addresses
# IMPORTANT: Customize per node
# Node 1: VIP + 172.16.91.101
# Node 2: VIP + 172.16.91.102
listen=udp:172.16.91.100:5060
listen=tcp:172.16.91.100:5060
listen=udp:172.16.91.101:5060
listen=tcp:172.16.91.101:5060

# Aliases
alias=voip.example.com

# Performance tuning
children=16
tcp_children=16
tcp_accept_aliases=yes
tcp_connection_lifetime=3605
tcp_max_connections=8192

# DNS
dns=no
rev_dns=no

# Disable via: headers on requests
auto_aliases=no

####### Modules Section ########

# Set module path
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

# Core modules
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"

# Database
loadmodule "db_postgres.so"
loadmodule "sqlops.so"

# Authentication & registration
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"

# Dialog tracking
loadmodule "dialog.so"

# Dispatcher (load balancing to FreeSWITCH)
loadmodule "dispatcher.so"

# NAT traversal
loadmodule "nathelper.so"
loadmodule "rtpengine.so"

# Anti-flood
loadmodule "pike.so"
loadmodule "htable.so"

# JSON-RPC
loadmodule "jsonrpcs.so"

# Permissions
loadmodule "permissions.so"

# UAC (for trunk auth)
loadmodule "uac.so"

# Statistics
loadmodule "statistics.so"
loadmodule "kex.so"
loadmodule "corex.so"

####### Module Parameters #########

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "auto_inv_100", 1)
modparam("tm", "auto_inv_100_reason", "Trying")

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_contacts", 5)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "min_expires", 60)
modparam("registrar", "default_expires", 600)
modparam("registrar", "gruu_enabled", 0)

# ----- usrloc params -----
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", 0)
modparam("usrloc", "hash_size", 4096)
modparam("usrloc", "timer_interval", 60)
modparam("usrloc", "db_update_as_insert", 0)
modparam("usrloc", "nat_bflag", 5)

# ----- auth_db params -----
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", 0)
modparam("auth_db", "user_column", "username")
modparam("auth_db", "domain_column", "domain")
modparam("auth_db", "password_column", "ha1")
modparam("auth_db", "load_credentials", "ha1")
modparam("auth_db", "use_domain", 1)

# ----- permissions params -----
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)

# ----- dispatcher params -----
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_probing_threshold", 3)

# ----- dialog params -----
modparam("dialog", "db_url", DBURL)
modparam("dialog", "db_mode", 1)
modparam("dialog", "default_timeout", 43200)
modparam("dialog", "profiles_with_value", "concurrent_calls")
modparam("dialog", "hash_size", 4096)

# ----- acc params -----
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_flag", 1)
modparam("acc", "db_missed_flag", 2)
modparam("acc", "db_extra", "src_user=$fU;src_domain=$fd;src_ip=$si;dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@voip.example.com")
modparam("nathelper", "received_avp", "$avp(RECEIVED)")

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")

# ----- pike params (anti-flood) -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
modparam("htable", "htable", "auth_failures=>size=14;autoexpire=3600")
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")

# ----- uac params -----
modparam("uac", "restore_mode", "auto")
modparam("uac", "restore_passwd", "VoIPUAC2025")

####### Routing Logic ########

request_route {
    # Per-request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if (t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Record-Route all requests (for in-dialog requests)
    if (!is_method("REGISTER|MESSAGE")) {
        record_route();
    }

    # Account requests
    if (!is_method("REGISTER|MESSAGE")) {
        setflag(1); # do accounting
    }

    # Handle requests within SIP dialogs
    if (has_totag()) {
        # Sequential requests within a dialog
        if (!loose_route()) {
            if (is_method("ACK")) {
                if (t_check_trans()) {
                    route(RELAY);
                    exit;
                }
                exit;
            }
            sl_send_reply("404", "Not here");
            exit;
        }

        # In-dialog requests
        route(RELAY);
        exit;
    }

    # REGISTER requests
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # Initial INVITE requests
    if (is_method("INVITE")) {
        # Enable dialog tracking
        dlg_manage();

        # Check concurrent call limit (per user)
        if (get_profile_size("concurrent_calls", "$fU") >= 10) {
            sl_send_reply("486", "Busy - Too Many Calls");
            exit;
        }
        set_dlg_profile("concurrent_calls", "$fU");

        # Authenticate
        route(AUTH);

        # Route to FreeSWITCH
        route(DISPATCH);
        exit;
    }

    # Other methods
    route(RELAY);
}

# Request initial checks
route[REQINIT] {
    # Flood detection
    if (!pike_check_req()) {
        xlog("L_ALERT", "ALERT: pike blocking $rm from $si\n");
        $sht(ipban=>$si) = 1;
        exit;
    }

    # Check banned IPs
    if ($sht(ipban=>$si) != $null) {
        xlog("L_ALERT", "ALERT: request from banned IP $si\n");
        exit;
    }

    # Sanity checks
    if (!sanity_check("17895", "7")) {
        xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    # Max-Forwards
    if (!mf_process_maxfwd_header("70")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # OPTIONS keepalive
    if (is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200", "Keepalive");
        exit;
    }
}

# NAT detection
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            add_contact_alias();
        }
        setflag(5); # NAT flag
    }
}

# Registration handler
route[REGISTRAR] {
    if (!is_method("REGISTER")) return;

    # Rate limiting for REGISTER
    if (!pike_check_req()) {
        xlog("L_ALERT", "ALERT: too many REGISTER from $si\n");
        sl_send_reply("503", "Too Many Requests");
        exit;
    }

    # Fix NAT
    if (isflagset(5)) {
        fix_nated_register();
    }

    # Authenticate
    if (!auth_check("$fd", "subscriber", "1")) {
        auth_challenge("$fd", "0");
        exit;
    }

    # Consume credentials
    consume_credentials();

    # Save location
    if (!save("location")) {
        sl_reply_error();
    }

    exit;
}

# Authentication
route[AUTH] {
    if (is_method("REGISTER") || from_uri==myself) {
        # Authenticate subscribers
        if (!auth_check("$fd", "subscriber", "1")) {
            auth_challenge("$fd", "0");
            exit;
        }
        consume_credentials();
    }
}

# Dispatch to FreeSWITCH
route[DISPATCH] {
    # Check if user/extension exists in voip DB
    # (This would be done via HTTP_ASYNC_CLIENT to voip-admin API)
    # For now, dispatch all INVITEs to FreeSWITCH

    # Set dispatcher set
    if (!ds_select_dst(DS_SETID, "4")) {
        send_reply("404", "No Destination");
        exit;
    }

    # Set request URI to FreeSWITCH
    xlog("L_INFO", "Dispatching call to FreeSWITCH: $du\n");

    route(RELAY);
}

# Relay requests
route[RELAY] {
    # Handle NAT
    if (isflagset(5)) {
        rtpengine_manage("trust-address replace-origin replace-session-connection ICE=remove");
    }

    # Enable failure route
    if (is_method("INVITE")) {
        t_on_failure("MANAGE_FAILURE");
    }

    # Relay
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Failure route - handle failed calls
failure_route[MANAGE_FAILURE] {
    if (t_is_canceled()) {
        exit;
    }

    # Try next FreeSWITCH if available
    if (t_check_status("408|500|503")) {
        if (ds_next_dst()) {
            xlog("L_INFO", "Trying next FreeSWITCH destination: $du\n");
            t_relay();
            exit;
        }
    }
}

# =============================================================================
# vim: set ts=4 sw=4 et:
